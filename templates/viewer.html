<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>JSON Browser</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Prism.js for code highlight -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(120deg, #f0f4f8 0%, #e2eafc 100%);
            min-height: 100vh;
        }
        .json-card {
            max-width: 1400px;
            margin: 7vh auto;
            box-shadow: 0 8px 32px 0 rgba(31,38,135,0.1);
            border-radius: 20px;
            background: #fff;
        }
        .json-header {
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 0.8em;
        }
        .prism-code {
            font-size: 1.05rem;
            border-radius: 8px;
            background: #282a36;
            color: #f8f8f2;
            padding: 1.2em;
            white-space: pre;
            word-break: normal;
            overflow-x: auto;
            transition: background 0.2s;
            tab-size: 2;
            -moz-tab-size: 2;
        }
        .prism-code.wrap,
        .prism-code.wrap code {
            white-space: pre-wrap !important;
            word-break: break-all !important;
            overflow-x: hidden !important;
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', 'Liberation Mono', 'Courier New', monospace;
        }
        .prism-code.wrap code {
            unicode-bidi: plaintext;
        }
        .prism-code code {
            tab-size: 2;
            -moz-tab-size: 2;
        }
        .btn-nav {
            min-width: 100px;
        }
        .page-indicator {
            font-size: 1.1em;
            font-weight: 500;
        }
        .progress {
            height: 7px;
            border-radius: 5px;
        }
        .btn-link {
            color: #0d6efd;
            text-decoration: none;
        }
        .btn-link:hover {
            color: #0a58ca;
            text-decoration: underline;
        }
        .toggle-btn {
            min-width: 150px;
        }
        html {
            scroll-behavior: auto !important;
        }

        /* --- NEW: Styles for JSON folding --- */
        .collapser {
            cursor: pointer;
            display: inline-block;
            width: 1em;
            text-align: center;
            margin-right: 4px;
            user-select: none;
            color: #a0a0a0;
            transition: transform 0.1s ease-in-out;
        }
        .collapser::before {
            content: '⊝'; /* Expanded state */
            font-size: 1.5em;
            color: #3498db;
            display: inline-block;
            vertical-align: middle;
        }
        .collapsed > .collapser::before {
            content: '⊕'; /* Collapsed state */
            transform: translateY(-1px);
            color: #7F5CC8;
        }
        .collapsible-content {
            display: inline;
        }
        .collapsed > .collapsible-content {
            display: none;
        }
        .ellipsis {
            display: none;
            color: #aaa;
            background-color: #3a3c4a;
            padding: 0 5px;
            border-radius: 3px;
            margin: 0 5px;
            font-style: italic;
            cursor: pointer;
        }
        .collapsed > .ellipsis {
            display: inline;
        }
        .collapsible {
            display: contents; /* Use 'contents' to not affect layout */
        }
        /* --- END: New Styles --- */

    </style>
</head>
<body>
    <div class="json-card p-4">
        <div class="json-header d-flex align-items-center mb-3">
            <i class="bi bi-braces-asterisk fs-3 me-2 text-primary"></i>
            <h3 class="mb-0">JSON Browser</h3>
            <div class="ms-auto d-flex flex-wrap gap-2 justify-content-end">
                <!-- NEW: Collapse/Expand All Buttons -->
                <button id="collapseAllBtn" type="button" class="btn btn-outline-secondary btn-sm" title="Collapse All">
                    <i class="bi bi-arrows-collapse"></i> Collapse All
                </button>
                <button id="expandAllBtn" type="button" class="btn btn-outline-secondary btn-sm" title="Expand All">
                    <i class="bi bi-arrows-expand"></i> Expand All
                </button>
                <!-- Unescape Strings Button -->
                <button id="unescapeToggleBtn" type="button" class="btn btn-outline-primary btn-sm toggle-btn" title="Unescape Strings (Alt+X)">
                    <i class="bi bi-magic"></i> Unescape Strings
                </button>
                <!-- Soft Wraps Button -->
                <button id="wrapToggleBtn" type="button" class="btn btn-outline-primary btn-sm toggle-btn" title="Soft Wraps (Alt+Z)">
                    <i class="bi bi-text-wrap"></i> Soft Wraps
                </button>
            </div>
        </div>
        <div>
            <pre class="prism-code language-json" id="jsonCode"><code class="language-json" id="jsonCodeInner">{{ data }}</code></pre>
        </div>
        <div class="my-3">
            <div class="progress">
                <div class="progress-bar bg-primary" role="progressbar" style="width: {{ (page/total*100)|round(2) }}%;" aria-valuenow="{{ page }}" aria-valuemin="0" aria-valuemax="{{ total }}"></div>
            </div>
        </div>
        <div class="d-flex justify-content-between align-items-center mb-2">
            <a href="/viewer?file_id={{ file_id }}&page={{ page - 1 }}" class="btn btn-outline-secondary btn-nav {% if page == 1 %}disabled{% endif %}">
                <i class="bi bi-arrow-left"></i> Previous
            </a>
            <span class="page-indicator">
                <i class="bi bi-list-ol"></i>
                Page {{ page }} / {{ total }} Total
            </span>
            <a href="/viewer?file_id={{ file_id }}&page={{ page + 1 }}" class="btn btn-outline-secondary btn-nav {% if page == total %}disabled{% endif %}">
                Next <i class="bi bi-arrow-right"></i>
            </a>
        </div>
        <div class="mt-3 text-center">
            <a href="/" class="btn btn-link">
                <i class="bi bi-arrow-bar-up"></i> Return to upload
            </a>
        </div>
    </div>
    <!-- Prism.js -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
    <script>
        // --- DOM Elements ---
        const wrapToggleBtn = document.getElementById('wrapToggleBtn');
        const unescapeToggleBtn = document.getElementById('unescapeToggleBtn');
        const jsonCode = document.getElementById('jsonCode');
        const jsonCodeInner = document.getElementById('jsonCodeInner');
        // NEW: Folding buttons
        const collapseAllBtn = document.getElementById('collapseAllBtn');
        const expandAllBtn = document.getElementById('expandAllBtn');

        // --- State Variables ---
        let isWrapped = false;
        let isUnescaped = false;

        // --- NEW: JSON Folding Logic ---

        /**
         * Finds the matching bracket for a given starting bracket node.
         * @param {Node[]} nodes - The list of sibling nodes to search within.
         * @param {number} startIndex - The index of the opening bracket.
         * @returns {number} - The index of the matching closing bracket, or -1 if not found.
         */
        function findMatchingBracket(nodes, startIndex) {
            const openChar = nodes[startIndex].textContent.trim();
            const closeChar = { '{': '}', '[': ']' }[openChar];
            let depth = 1;

            for (let i = startIndex + 1; i < nodes.length; i++) {
                const text = nodes[i].textContent.trim();
                if (text === openChar) {
                    depth++;
                } else if (text === closeChar) {
                    depth--;
                    if (depth === 0) {
                        return i;
                    }
                }
            }
            return -1; // Not found
        }

        /**
         * Recursively processes nodes to make JSON parts foldable.
         * @param {HTMLElement} parentElement - The element whose child nodes will be processed.
         */
        function makeJsonFoldable(parentElement) {
            const nodes = Array.from(parentElement.childNodes);
            let i = 0;
            while (i < nodes.length) {
                const node = nodes[i];

                // Check if it's a punctuation token for '{' or '['
                if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('token') && node.classList.contains('punctuation') && (node.textContent === '{' || node.textContent === '[')) {

                    const endIndex = findMatchingBracket(nodes, i);

                    if (endIndex !== -1) {
                        // Create a container for the collapsible section
                        const collapsibleContainer = document.createElement('span');
                        collapsibleContainer.className = 'collapsible';

                        // Create the collapser toggle button
                        const collapser = document.createElement('span');
                        collapser.className = 'collapser';

                        // Create the content wrapper
                        const contentWrapper = document.createElement('span');
                        contentWrapper.className = 'collapsible-content';

                        // Move the content nodes into the wrapper
                        const contentNodes = nodes.slice(i + 1, endIndex);
                        contentNodes.forEach(contentNode => contentWrapper.appendChild(contentNode.cloneNode(true)));

                        // Count items for the ellipsis
                        const isObject = node.textContent === '{';
                        const itemCount = isObject
                            ? contentWrapper.querySelectorAll('.token.property').length
                            : (contentWrapper.textContent.trim() ? contentWrapper.textContent.trim().split(',').length : 0);

                        // Create the ellipsis
                        const ellipsis = document.createElement('span');
                        ellipsis.className = 'ellipsis';
                        ellipsis.textContent = `... ${itemCount} ${isObject ? 'keys' : 'items'} ...`;

                        // Assemble the new structure
                        collapsibleContainer.appendChild(collapser);
                        collapsibleContainer.appendChild(node.cloneNode(true)); // open bracket
                        collapsibleContainer.appendChild(ellipsis);
                        collapsibleContainer.appendChild(contentWrapper);
                        collapsibleContainer.appendChild(nodes[endIndex].cloneNode(true)); // close bracket

                        // Add click event to toggle
                        const toggleCollapse = () => collapsibleContainer.classList.toggle('collapsed');
                        collapser.addEventListener('click', toggleCollapse);
                        ellipsis.addEventListener('click', toggleCollapse);

                        // Recursively make the inner content foldable
                        makeJsonFoldable(contentWrapper);

                        // Replace the original nodes with the new collapsible structure
                        const nodesToRemove = nodes.slice(i, endIndex + 1);
                        parentElement.replaceChild(collapsibleContainer, nodesToRemove[0]);
                        nodesToRemove.slice(1).forEach(n => n.remove());

                        // Update nodes array and index for the next iteration
                        // This is a bit complex, so we re-fetch the nodes.
                        // A more performant way would be to adjust index, but this is more robust.
                        return makeJsonFoldable(parentElement); // Restart processing from the parent
                    }
                }
                i++;
            }
        }

        // --- END: JSON Folding Logic ---


        function storeOriginalStringValues() {
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');
            stringElements.forEach(span => {
                if (!span.dataset.originalText) { // Store only if not already stored
                    span.dataset.originalText = span.textContent;
                }
            });
        }

        function linkifyJsonUrls() {
            const urlRegex = /^"https?:\/\/[^\s"]+"$/;
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');

            stringElements.forEach(span => {
                // If it already contains a link, skip it
                if (span.querySelector('a')) return;

                const text = isUnescaped ? ('"' + JSON.parse(span.dataset.originalText) + '"') : span.dataset.originalText;

                if (urlRegex.test(text)) {
                    const url = text.substring(1, text.length - 1);
                    const link = document.createElement('a');
                    link.href = url;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.textContent = text;
                    link.style.color = 'inherit';
                    link.style.textDecoration = 'underline';

                    // Clear the span and append the link
                    span.innerHTML = '';
                    span.appendChild(link);
                }
            });
        }

        function applyEscapeTransformation() {
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');
            stringElements.forEach(span => {
                const originalText = span.dataset.originalText;
                if (!originalText) return;

                const targetElement = span.querySelector('a') || span;

                if (isUnescaped) {
                    try {
                        const unescapedString = JSON.parse(originalText);
                        targetElement.textContent = '"' + unescapedString + '"';
                    } catch (e) {
                        targetElement.textContent = originalText;
                        console.warn('Failed to parse JSON string:', originalText, e);
                    }
                } else {
                    targetElement.textContent = originalText;
                }
            });
        }

        function updateWrapBtn() {
            if (isWrapped) {
                wrapToggleBtn.innerHTML = '<i class="bi bi-text-nowrap"></i> No Wrap';
                wrapToggleBtn.classList.replace('btn-outline-primary', 'btn-primary');
            } else {
                wrapToggleBtn.innerHTML = '<i class="bi bi-text-wrap"></i> Soft Wraps';
                wrapToggleBtn.classList.replace('btn-primary', 'btn-outline-primary');
            }
            jsonCode.classList.toggle('wrap', isWrapped);
        }

        function updateUnescapeBtn() {
            if (isUnescaped) {
                unescapeToggleBtn.innerHTML = '<i class="bi bi-quote"></i> Show Escaped';
                unescapeToggleBtn.classList.replace('btn-outline-primary', 'btn-primary');
            } else {
                unescapeToggleBtn.innerHTML = '<i class="bi bi-magic"></i> Unescape Strings';
                unescapeToggleBtn.classList.replace('btn-primary', 'btn-outline-primary');
            }
        }

        function updateJsonDisplay() {
            applyEscapeTransformation();
            linkifyJsonUrls(); // Re-apply linkify after potential text changes
        }

        wrapToggleBtn.addEventListener('click', function () {
            isWrapped = !isWrapped;
            sessionStorage.setItem('isJsonWrapped', isWrapped);
            updateWrapBtn();
        });

        unescapeToggleBtn.addEventListener('click', function() {
            isUnescaped = !isUnescaped;
            sessionStorage.setItem('isJsonUnescaped', isUnescaped);
            updateUnescapeBtn();
            updateJsonDisplay();
        });

        // NEW: Event listeners for collapse/expand all
        collapseAllBtn.addEventListener('click', () => {
            jsonCodeInner.querySelectorAll('.collapsible').forEach(el => el.classList.add('collapsed'));
        });

        expandAllBtn.addEventListener('click', () => {
            jsonCodeInner.querySelectorAll('.collapsible').forEach(el => el.classList.remove('collapsed'));
        });


        document.addEventListener('keydown', function (event) {
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                return;
            }
            if (event.key === 'ArrowLeft') {
                const prevBtn = document.querySelector('.btn-nav:not(.disabled)[href*="page={{ page - 1 }}"]');
                if (prevBtn) prevBtn.click();
            }
            if (event.key === 'ArrowRight') {
                const nextBtn = document.querySelector('.btn-nav:not(.disabled)[href*="page={{ page + 1 }}"]');
                if (nextBtn) nextBtn.click();
            }
            if (event.altKey && event.code === 'KeyZ') {
                event.preventDefault();
                wrapToggleBtn.click();
            }
            if (event.altKey && event.code === 'KeyX') {
                event.preventDefault();
                unescapeToggleBtn.click();
            }
        });

        const pageNavButtons = document.querySelectorAll('.btn-nav');
        pageNavButtons.forEach(button => {
            button.addEventListener('click', function() {
                const scrollY = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const ratio = docHeight > 0 ? scrollY / docHeight : 0;
                sessionStorage.setItem('scrollRatio', ratio);
            });
        });

        // --- Page Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            // IMPORTANT: Explicitly highlight first, as the folding logic depends on Prism's output.
            Prism.highlightElement(jsonCodeInner, false, function() {

                // 1. Make the JSON foldable
                makeJsonFoldable(jsonCodeInner);

                // 2. Store original string values for unescaping
                storeOriginalStringValues();

                // 3. Load saved states
                const savedWrapState = sessionStorage.getItem('isJsonWrapped');
                if (savedWrapState === 'true') {
                    isWrapped = true;
                }

                const savedUnescapeState = sessionStorage.getItem('isJsonUnescaped');
                if (savedUnescapeState === 'true') {
                    isUnescaped = true;
                }

                // 4. Update UI based on states
                updateWrapBtn();
                updateUnescapeBtn();
                updateJsonDisplay();

                // 5. Restore scroll position
                const savedRatio = sessionStorage.getItem('scrollRatio');
                if (savedRatio !== null) {
                    // Use a small timeout to allow the DOM to fully render after folding logic
                    setTimeout(() => {
                        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                        const targetY = docHeight > 0 ? Math.round(docHeight * parseFloat(savedRatio)) : 0;
                        window.scrollTo({
                            top: targetY,
                            behavior: 'instant'
                        });
                    }, 50);
                }
            });
        });

        const returnBtn = document.querySelector('a[href="/"]');
        if (returnBtn) {
            returnBtn.addEventListener('click', function() {
                // Clear session storage on return to have a fresh start
                sessionStorage.removeItem('isJsonWrapped');
                sessionStorage.removeItem('isJsonUnescaped');
                sessionStorage.removeItem('scrollRatio');
            });
        }
    </script>
</body>
</html>
