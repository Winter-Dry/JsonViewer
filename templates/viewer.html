<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>JSON Browser</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Prism.js for code highlight -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(120deg, #f0f4f8 0%, #e2eafc 100%);
            min-height: 100vh;
        }
        .json-card {
            max-width: 1400px;
            margin: 7vh auto;
            box-shadow: 0 8px 32px 0 rgba(31,38,135,0.1);
            border-radius: 20px;
            background: #fff;
        }
        .json-header {
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 0.8em;
        }
        .prism-code {
            font-size: 1.05rem;
            border-radius: 8px;
            background: #282a36;
            color: #f8f8f2;
            padding: 1.2em;
            white-space: pre;
            word-break: normal;
            overflow-x: auto;
            transition: background 0.2s;
            tab-size: 2;
            -moz-tab-size: 2;
        }
        /* Change line */
        .prism-code.wrap,
        .prism-code.wrap code {
            white-space: pre-wrap !important;
            word-break: break-all !important;
            overflow-x: hidden !important;
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', 'Liberation Mono', 'Courier New', monospace;
        }
        .prism-code.wrap code {
            unicode-bidi: plaintext;
        }
        .prism-code code {
            tab-size: 2;
            -moz-tab-size: 2;
        }
        .btn-nav {
            min-width: 100px;
        }
        .page-indicator {
            font-size: 1.1em;
            font-weight: 500;
        }
        .progress {
            height: 7px;
            border-radius: 5px;
        }
        .btn-link {
            color: #0d6efd;
            text-decoration: none;
        }
        .btn-link:hover {
            color: #0a58ca;
            text-decoration: underline;
        }
        .toggle-btn {
            min-width: 150px; /* 增加了按钮宽度以容纳更长的文本 */
        }
        html {
        scroll-behavior: auto !important;
    }
    </style>
</head>
<body>
    <div class="json-card p-4">
        <div class="json-header d-flex align-items-center mb-3">
            <i class="bi bi-braces-asterisk fs-3 me-2 text-primary"></i>
            <h3 class="mb-0">JSON Browser</h3>
            <div class="ms-auto">
                <!-- NEW: Unescape Strings Button -->
                <button id="unescapeToggleBtn" type="button" class="btn btn-outline-primary btn-sm toggle-btn" title="Unescape Strings (Alt+X)">
                    <i class="bi bi-magic"></i> Unescape Strings
                </button>
                <!-- Soft Wraps Button -->
                <button id="wrapToggleBtn" type="button" class="btn btn-outline-primary btn-sm toggle-btn" title="Soft Wraps (Alt+Z)">
                    <i class="bi bi-text-wrap"></i> Soft Wraps
                </button>
            </div>
        </div>
        <div>
            <pre class="prism-code language-json" id="jsonCode"><code class="language-json" id="jsonCodeInner">{{ data }}</code></pre>
        </div>
        <div class="my-3">
            <div class="progress">
                <div class="progress-bar bg-primary" role="progressbar" style="width: {{ (page/total*100)|round(2) }}%;" aria-valuenow="{{ page }}" aria-valuemin="0" aria-valuemax="{{ total }}"></div>
            </div>
        </div>
        <div class="d-flex justify-content-between align-items-center mb-2">
            <a href="/viewer?page={{ page - 1 }}" class="btn btn-outline-secondary btn-nav {% if page == 1 %}disabled{% endif %}">
                <i class="bi bi-arrow-left"></i> Previous
            </a>
            <span class="page-indicator">
                <i class="bi bi-list-ol"></i>
                Page {{ page }} / {{ total }} Total
            </span>
            <a href="/viewer?page={{ page + 1 }}" class="btn btn-outline-secondary btn-nav {% if page == total %}disabled{% endif %}">
                Next <i class="bi bi-arrow-right"></i>
            </a>
        </div>
        <div class="mt-3 text-center">
            <a href="/" class="btn btn-link">
                <i class="bi bi-arrow-bar-up"></i> Return to upload
            </a>
        </div>
    </div>
    <!-- Prism.js -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
    <script>
        // --- DOM Elements ---
        const wrapToggleBtn = document.getElementById('wrapToggleBtn');
        const unescapeToggleBtn = document.getElementById('unescapeToggleBtn');
        const jsonCode = document.getElementById('jsonCode');
        const jsonCodeInner = document.getElementById('jsonCodeInner');

        // --- State Variables ---
        let isWrapped = false;
        let isUnescaped = false;

        /**
         * 遍历所有由 Prism.js 标记的字符串 span，
         * 并将它们最原始的文本内容存储在 data-original-text 属性中。
         * 这一步至关重要，因为它为我们提供了一个“干净”的数据源，
         * 无论后续进行多少次“转义/反转义”切换，我们总能恢复到最初的状态。
         */
        function storeOriginalStringValues() {
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');
            stringElements.forEach(span => {
                span.dataset.originalText = span.textContent;
            });
        }

        /**
         * 将 JSON 字符串中的 URL 转换为可点击的 <a> 标签。
         * 这个函数现在会在每次显示更新后调用，以确保链接在两种模式下都有效。
         */
        function linkifyJsonUrls() {
            const urlRegex = /^"https?:\/\/[^\s"]+"$/;
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');

            stringElements.forEach(span => {
                // 如果 span 内部已经有其他元素（比如之前创建的 <a> 标签），就跳过它。
                if (span.children.length > 0) return;

                const text = span.textContent;
                if (urlRegex.test(text)) {
                    const url = text.substring(1, text.length - 1);
                    const link = document.createElement('a');
                    link.href = url;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.textContent = text;
                    link.style.color = 'inherit';
                    link.style.textDecoration = 'underline';
                    span.innerHTML = '';
                    span.appendChild(link);
                }
            });
        }

        /**
         * 核心功能：根据 isUnescaped 状态切换字符串的显示。
         * true:  将字符串内容进行 JSON 解析，显示 \n 为换行符等。
         * false: 恢复为 data-original-text 中存储的原始带 \\n 的文本。
         */
        function applyEscapeTransformation() {
            const stringElements = jsonCodeInner.querySelectorAll('.token.string');
            stringElements.forEach(span => {
                const originalText = span.dataset.originalText;
                if (!originalText) return; // 如果没有原始文本，则跳过

                if (isUnescaped) {
                    try {
                        // 使用 JSON.parse 来正确处理所有转义序列 (\n, \t, \", \\, \uXXXX 等)
                        // originalText 是一个带引号的JSON字符串，如 `"hello\\nworld"`
                        const unescapedString = JSON.parse(originalText);
                        // 我们需要把引号加回去，因为 Prism 的 .string token 代表整个带引号的部分
                        span.textContent = '"' + unescapedString + '"';
                    } catch (e) {
                        // 如果解析失败（例如，字符串格式不正确），则保持原样，避免页面崩溃
                        span.textContent = originalText;
                        console.warn('Failed to parse JSON string:', originalText, e);
                    }
                } else {
                    // 恢复到最原始的文本
                    span.textContent = originalText;
                }
            });
        }

        /**
         * 更新“自动换行”按钮的文本、图标和样式。
         */
        function updateWrapBtn() {
            if (isWrapped) {
                wrapToggleBtn.innerHTML = '<i class="bi bi-text-nowrap"></i> No Wrap';
                wrapToggleBtn.classList.replace('btn-outline-primary', 'btn-primary');
            } else {
                wrapToggleBtn.innerHTML = '<i class="bi bi-text-wrap"></i> Soft Wraps';
                wrapToggleBtn.classList.replace('btn-primary', 'btn-outline-primary');
            }
            jsonCode.classList.toggle('wrap', isWrapped);
        }

        /**
         * 更新“反转义字符串”按钮的文本、图标和样式。
         */
        function updateUnescapeBtn() {
            if (isUnescaped) {
                unescapeToggleBtn.innerHTML = '<i class="bi bi-quote"></i> Show Escaped';
                unescapeToggleBtn.classList.replace('btn-outline-primary', 'btn-primary');
            } else {
                unescapeToggleBtn.innerHTML = '<i class="bi bi-magic"></i> Unescape Strings';
                unescapeToggleBtn.classList.replace('btn-primary', 'btn-outline-primary');
            }
        }

        /**
         * 一个统一的函数，用于在状态改变后刷新整个 JSON 显示区域。
         * 它会先应用转义变换，然后再处理 URL 链接。顺序很重要。
         */
        function updateJsonDisplay() {
            applyEscapeTransformation();
            linkifyJsonUrls();
        }

        // --- Event Listeners ---

        wrapToggleBtn.addEventListener('click', function () {
            isWrapped = !isWrapped;
            sessionStorage.setItem('isJsonWrapped', isWrapped);
            updateWrapBtn();
        });

        unescapeToggleBtn.addEventListener('click', function() {
            isUnescaped = !isUnescaped;
            sessionStorage.setItem('isJsonUnescaped', isUnescaped);
            updateUnescapeBtn();
            updateJsonDisplay();
        });

        document.addEventListener('keydown', function (event) {
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                return;
            }
            // ← Previous page
            if (event.key === 'ArrowLeft') {
                const prevBtn = document.querySelector('.btn-nav:not(.disabled)[href*="page={{ page - 1 }}"]');
                if (prevBtn) prevBtn.click();
            }
            // → Next page
            if (event.key === 'ArrowRight') {
                const nextBtn = document.querySelector('.btn-nav:not(.disabled)[href*="page={{ page + 1 }}"]');
                if (nextBtn) nextBtn.click();
            }
            // Alt + Z for Soft Wraps
            if (event.altKey && event.code === 'KeyZ') {
                event.preventDefault();
                wrapToggleBtn.click();
            }
            // Alt + X for Unescape Strings
            if (event.altKey && event.code === 'KeyX') {
                event.preventDefault();
                unescapeToggleBtn.click();
            }
        });

        const pageNavButtons = document.querySelectorAll('.btn-nav');
        pageNavButtons.forEach(button => {
            button.addEventListener('click', function() {
                const scrollY = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const ratio = docHeight > 0 ? scrollY / docHeight : 0;
                sessionStorage.setItem('scrollRatio', ratio);
            });
        });

        // --- Page Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            storeOriginalStringValues();

            const savedWrapState = sessionStorage.getItem('isJsonWrapped');
            if (savedWrapState === 'true') {
                isWrapped = true;
            }

            const savedUnescapeState = sessionStorage.getItem('isJsonUnescaped');
            if (savedUnescapeState === 'true') {
                isUnescaped = true;
            }

            updateWrapBtn();
            updateUnescapeBtn();
            updateJsonDisplay();

            const savedRatio = sessionStorage.getItem('scrollRatio');
            if (savedRatio !== null) {
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const targetY = docHeight > 0 ? Math.round(docHeight * parseFloat(savedRatio)) : 0;
                window.scrollTo({
                    top: targetY,
                    behavior: 'instant'
                });
            }
        });

        const returnBtn = document.querySelector('a[href="/"]');
        if (returnBtn) {
            returnBtn.addEventListener('click', function() {
                 sessionStorage.removeItem('isJsonWrapped');
                 sessionStorage.removeItem('isJsonUnescaped');
                 sessionStorage.removeItem('scrollRatio');
            });
        }
    </script>
</body>
</html>
